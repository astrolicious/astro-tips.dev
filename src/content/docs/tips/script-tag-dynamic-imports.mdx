---
title: Dynamic imports in module scripts
description: How dynamic imports offer granular control over fetch and execution order
astroRange: ^4.0.0
---

Astro bundles and processes `<script>` tags into [`type="module"`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) for us automatically, which makes scripts execute similiar to [`defer`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#defer) by default. This is great for a balance performance and time to interactivity/hydration. 

With [Interaction to Next Paint](https://web.dev/blog/inp-cwv-launch) (INP) officially replacing [First Input Delay](https://web.dev/articles/fid) (FID) it might seem absurd to suggest replacing a static import inside a module script to a dynamic one, but if done correctly it can be useful sometimes.

## Granular control

### Static Imports

Static imports ensure that your code is hydrated and ready to run as soon as possible, without affecting [First Contentful Paint](https://web.dev/articles/fcp) (FCP) or [Largest Contentful Paint](https://web.dev/articles/lcp) (LCP). This is important for INP because it ensures that any interactive elements are ready to react to interaction immediately.

### Dynamic Imports

Dynamic imports provide fine-grained control over when your module is imported (downloaded). Since static imports will all be fetched, parsed, and evaluated at the beginning of a module script's execution, importing two expensive modules in the same module script tag can cause delays in the execution of code that only depends on the first module. Dynamic imports allow you to either import a module only when it is needed, or dictate the order of imports allowing for manually optimization of network requests.

### Controlling Network Requests

Dynamic imports also allow you to control the sequence of network requests. Instead of fetching all modules in parallel, which is the default behavior when using multiple static imports or separate module scripts, dynamic imports enable you to ensure that one module is downloaded first before initiating the fetch for the next module. This can be particularly useful when you have modules that are critical for immediate user interaction and others that are less critical or if you are supporting users with very low bandwidth.

## Example

Here's a basic example:


```astro
<script>
  import module1 from '...';
  module1();

  const module2  = await import('...');
  module2();
</script>
```

or

```astro
<script>
  import module1 from '...';
  module1();

  document.addEventListener('some-event', async () => {
    const module2 = await import('...');
    module2();
  });
</script>
```

If you want to see a more interactive example that might help explain or let you test things out better you can: 


[![Open in StackBlitz](https://developer.stackblitz.com/img/open_in_stackblitz.svg)](https://stackblitz.com/github/astrolicious/astro-tips.dev/tree/main/examples/script-tag-dynamic-imports)

[![View on GitHub](/view-on-github.svg)](https://github.com/astrolicious/astro-tips.dev/tree/main/examples/script-tag-dynamic-imports)


## Use Cases

1. __Granular Control__: Ensuring that modules critical for snappy INP scores receive top priority by dynamically importing less critical modules after the critical ones are processed.

2. __Recreate [Client Directives](https://docs.astro.build/en/reference/directives-reference/#client-directives) in `<script>`s__: Effects similiar to [`client:visible`](https://docs.astro.build/en/reference/directives-reference/#clientvisible), [`client:media`](https://docs.astro.build/en/reference/directives-reference/#clientmedia) and [`client:idle`](https://docs.astro.build/en/reference/directives-reference/#clientidle) can all be achieved with this technique.

3. __Feature Flags__: Dynamically importing modules based on feature flags. For example, loading a specific feature only for users who have opted in or who meet certain criteria.

4. __Device-Specific Code__: Importing desktop-specific code that doesn't need to be downloaded on mobile devices.

2. __Rarely Clicked Buttons__: A button that might be rarely clicked, and when it is, the module needed to hydrate it is small enough that pre-hydration is unnecessary.

## Warning

INP was made an official Core Web Vital for a reason, when a user clicks a button they expect it to react instantly. If you dynamically import heavy code that hydrates a button only when it is clicked you that could create a delay between interaction and next paint. Also if you are using this technique to control network requests you are opting out of parallel fetching, which is a feature of `type="module"` so this should only be implemented in special circumstances.